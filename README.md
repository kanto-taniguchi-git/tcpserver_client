## ソケットとは
ネットワーク上でデータをやり取りするためのエンドポイント（接点）を提供する仕組みです。プログラミングにおいては、ソケットはネットワーク通信のためのAPI（アプリケーションプログラミングインターフェース）として機能し、異なるコンピュータ間でデータを送受信するための手段を提供する。

## TCPとUDPの違い
**TCP**  
+ 接続指向プロトコルであり、通信を開始する前にハンドシェイクを行い、確実な接続を確立します。このプロセスにより、**双方のデバイス間での信頼性の高い通信チャネル**が構築される。  

+ データの順序保証、エラーチェック、データの再送機能を提供し、送信されたデータが確実に受信側に到達し、正確な順序で再構成されることを保証する。  

+ ハンドシェイク、エラーチェック、データの再送などのプロセスにより、**UDPよりも遅くなる**可能性がありますが、これによりデータの信頼性と順序性が確保される。  

+ 信頼性の高い通信が必要なアプリケーション（例: ウェブブラウザ、メール送信、ファイル転送）に適しています。  

**UDP**  
+ 接続レスプロトコルであり、事前の接続確立なしにデータを送信します。これにより、ハンドシェイクの遅延がなく、より**高速なデータ転送が可能**になりますが、**信頼性は低下**します。  

+ データの到達を保証しないため、パケットの損失や順序の乱れが発生する可能性がある。  

+ 接続の確立やエラーチェックのプロセスがないため、リアルタイム通信など、速度が重要なアプリケーションに適している。

+ 遅延が許容できないアプリケーション（例: リアルタイムビデオやオーディオストリーミング、オンラインゲーム）に適しています。  

**今回はTCPを学習する**

**3ウェイハンドシェイクとは**  
TCPにおいて信頼性の高い通信接続を確立するためのプロセス  
1. SYN送信  
+ クライアントからサーバーへ「SYN（Synchronize Sequence Numbers）」フラグが設定されたパケットを送信します。このパケットには、クライアントが通信を開始する際に使用するシーケンス番号が含まれています。  
・このステップでクライアントは接続の開始意志をサーバーに通知します。 
2. SYN+ACK応答  
+ サーバーはクライアントからのSYNパケットを受け取ると、「SYN」と「ACK（Acknowledgement）」のフラグが設定されたパケットをクライアントに送り返します。このパケットには、サーバーが通信に使用するシーケンス番号と、クライアントのSYNパケットのシーケンス番号に1を加えた確認応答番号が含まれています。  
+ このステップでサーバーは、クライアントからの接続要求を受け入れ、自身の接続開始意志もクライアントに通知します。
3. ACK送信  
+ クライアントはサーバーからのSYN+ACKパケットを受け取ると、ACKフラグが設定されたパケットをサーバーに送ります。このパケットには、サーバーのSYNパケットのシーケンス番号に1を加えた確認応答番号が含まれています。  
+ このステップでクライアントは、サーバーからの接続要求の受け入れを確認し、接続の確立を完了します。

## その他
**#!/usr/bin/python3**  
・「#!」はシバンと呼ばれるスクリプトを解釈するために使用されるインタープリタのパスを後ろに記述する。  
・Linuxで「which python3」とターミナルで入力するとpython3のインストール先が表示される。  
・ファイルの先頭に記述する。

**バインド**  
ソケットにローカルアドレス（IPアドレスとポート番号の組み合わせ）を割り当てるプロセスのことです。この操作により、そのアドレスへのすべての入ってくるデータは、バインドされたソケットを通じて処理されるようになります。  

**host名の調べかた**  
```zsh
hostname
```

**ローカルIPの調べかた**  
```zsh
hostname -I
```

または
```zsh
ip a
```

Windows  
```
ipconfig -all
```

**現在使用されているシェルの調べかた(Windows×)**
```zsh
echo $SHELL
```

**kaliのIPアドレスを一時的に変更(IPアドレスとデフォルトゲートウェイをそれぞれ設定)**  
```zsh
sudo ip addr add 192.168.0.100/24 dev eth0
sudo ip route add default via 192.168.0.1
```
※devの後にはネットワークインターフェースを指定する。  
※viaの後にはデフォルトゲートウェイのIPアドレスを指定する。  

**ソケットモジュール**  
TCPやDPソケットなどを通じてネットワーク接続を直接作成、管理、操作することができる。

**Nmapの環境構築**  
ネットワークを探索し、ホストやサービスの検出、セキュリティスキャンなどができる。
```zsh
pip3 install python-nmap
```

**スキャンの種類**  
+ Syn Ack Scan  
  + このスキャンタイプは、TCPポートスキャンの一種で、より一般的に "半開" スキャンとして知られている。
  + SYNスキャンは、TCP接続の初期段階であるSYNパケット（接続要求）をターゲットに送信し、応答を待つ。
  + ターゲットからSYN-ACK（接続受諾）応答が返された場合、そのポートは「開いている」と見なされます。しかし、RST（リセット）応答が返された場合、そのポートは「閉じている」とみなされる。
  + この手法は、フルTCP接続を完了せずにポートの状態を判定するため、**ステルス性が高い**とされる。スキャンが対象システムのログに記録されにくいからである。

+ UDP Scan
  + UDPスキャンは、ターゲットのネットワーク上で開いているUDPポートを識別するために使用される。
  + UDPは接続指向ではないため、UDPスキャンはTCPスキャンよりも時間がかかり、不正確な結果を返すことがある。
  + スキャナーはUDPポートに対してパケットを送信し、応答を監視する。特定の種類の応答（たとえば、ICMPポート到達不可メッセージ）を受け取ると、そのポートは閉じているとみなされる。しかし、応答がない場合、そのポートは開いている(つまり、何らかのサービスがそのポートで待機している)か、またはフィルタリングされている可能性がある。

+ Comprehensive Scan (包括的スキャン)
  + このスキャンは、**上記のスキャン手法を組み合わせた**もので、より詳細な情報を提供する。
  + 包括的スキャンには、SYNスキャン、UDPスキャンの他に、オペレーティングシステムの検出、サービスのバージョン検出、スクリプトを使ったスキャンなどが含まれる場合がある。
  + このタイプのスキャンは、ネットワーク上の機器に関する可能な限り多くの情報を収集するために使用される。これには、開いているポートだけでなく、実行されているサービスの種類やバージョン、オペレーティングシステムの詳細などが含まれる。
  + 包括的スキャンは、最も時間がかかり、ネットワークへの影響も大きいですが、**最も詳細な情報を提供する**。

**SYNスキャンの実行**  
```zsh
scanner.scan(ip_addr, '1-1024', '-v -sS')
```
※ip_addrにはスキャン対象のIPアドレスを指定する。  

**UDPスキャンの実行**  
```zsh
scanner.scan(ip_addr, '1-1024', '-v -sU')
```
※時間がかかる  

**包括的スキャンの実行**  
```zsh
scanner.scan(ip_addr, '1-1024', '-v -sS -sV -sC -A -O')
```
**ASCII**  
英数字といくつかの特殊文字のみをサポートしており、絵文字は含まれていない。  

**UTF-8**  
世界中のほぼすべての文字体系を表現できる国際的な文字セットで、各文字は固有のコードポイント（番号）に割り当てられています。UTF-8はこのUnicodeの文字を表現するために、1文字あたり1バイトから4バイトを使用します。デコードで不具合が出る可能性があるので絵文字は使わない。

**環境で苦労した点**  
kaliのタスクバーが消える問題が発生したが以下の方法で解決した。
```zsh
rm -rf ~/.cache/sessions/*
```
